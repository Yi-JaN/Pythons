#泡沫排序(氣泡排序)(由小至大跟由大至小)
n=[] #設1個陣列
for i in range(0,5,1) : #for循環5次0<5 n陣列取5個自己輸入的值
    n+=[int(input())]
print(n)
m=len(n)  #先算出n陣列長度
for j in range(0,m,1) :  #看n陣列長度多少,外圈跟著循環多少,每一次外圈會帶動內圈循環排出目前的值由小到大或由大至小
    for k in range(0,m-1,1) : #內圈開始由小到大排序 注意:外圈run幾次 內圈就跟著排序由小到大幾次,排到最完美為止
        if n[k]>n[k+1] : #這裡是比較區 由小到大是n[k]>n[k+1] 由大至小是n[k]<n[k+1]
            v=n[k]
            n[k]=n[k+1]
            n[k+1]=v
for k1 in range(0,m,1) : #來到這代表已經排出最完美的一維陣列,並且依照for k1,1個
    print(n[k1],end=" ")  #1個列印出來
print()

#n->[5, 2, 3, 7, 1]
#A: 7 5 3 2 1  <-由大至小
#n->[5, 2, 3, 7, 1]
#A: 1 2 3 5 7  <-由小至大
#
#注意:為什麼內圈for k 要m-1呢? 原因是因為排到最後一個值,後面就沒值做排序比較,最後一
#個值就最後一個值了,哪來的最後一個值在往後取值做排序,ex:假設n.length為5 那0就跟1比
#在來 1跟2比 2跟3 3跟4 之後4就最後了,所以後面沒值就沒得+1互相比較

#補充: 那為什麼要加外圈for的原因是因為如果不加,那他內圈排出來不管是由小至大還由大至小
# 都只有循環排1次,而且還是排出半成品出來,所以如果要1個1個由小至大或由大至小,那一定要放外圈
#for 看m算出n陣列幾個值,外圈就跟著循環幾次,之後外圈帶動內圈排出最完美的由小到大或
#由大至小

#假設m=len(n)n為5 n=[5,2,3,7,1]
#外圈帶動內圈循環次數    由小至大(原本)    由小至大(更改)
#      j=0  1           5,2,3,7,1    ->  2 3 5 1 7
#      j=1  2           2,3,5,1,7    ->  2 3 1 5 7
#      j=2  3           2,3,1,5,7    ->  2 1 3 5 7
#      j=3  4           2,1,3,5,7    ->  1 2 3 5 7
#      j=4  5           1,2,3,5,7    ->  1 2 3 5 7 <-最後最完美的排序,也是最後的答案!  