data=[[0]*4 for o in range(3)] #輸入一個二維陣列 設定為高3值4
for a in range(0,3,1) : #先自己輸入值在取值丟入data二維陣列裡
    for b in range(0,4,1) :
        data[a][b]=int(input()) #每循環1次取1個自己輸入的值轉正整數給目前的data高[a]值[b]位置上
for aa in range(0,3,1) : #來到這邊是先列印未泡沫排序前, for aa當高
    for bb in range(0,4,1) : #for bb當值
        print(data[aa][bb],end="\t") #每循環1次取data目前的高[aa]值[bb]位置上的值列印,並且在"\t"
    print()  #每列印完一行就來到這邊換行,換下一行的列印
print() #這print()是做換行,做為前後者區別    
for i in range(0,3,1) : #這裡開始做泡沫排序,for i是取目前的data的高
    a=len(data[i]) #每循環i之後就往下,算data目前的高[i]是多少個值
    for j in range(0,a,1) : #此高的值有幾個就丟入for j,for j是做針對此高有幾個值就循環幾次,然後搭配內圈for k循環盡可能排出最完美狀態的泡沫排序
        for k in range(0,(a-1),1) : #for k角色是當目前此高裡的值,然後for j再搭配for k每一次循環盡可能排出完美狀態的泡沫排序
            if data[i][k]<data[i][k+1] : #< 是此高裡的值比此高裡的下一個值還要小就進入,<是由大至小 >是由小至大
                xxx=data[i][k]
                data[i][k]=data[i][k+1]
                data[i][k+1]=xxx
for aaa in range(0,3,1) : #最後來到這裡,就是做泡沫排序後的列印,for aaa當高
    for bbb in range(0,4,1) : #for bbb當值
        print(data[aaa][bbb],end="\t") #每循環1次取data目前的高[aaa]值[bbb]位置上的值列印,並且在"\t"
    print() #每列印完一行就來到這邊換行,換下一行列印               

#輸入->11 22 33 44 6 8 1 7 6 9 71 5
#輸出->11  22  33  44
#      6   8   1   7 
#      6   9   71  5 (<-未泡沫排序前)
#
#      44  33  22  11
#      8   7   6   1
#      71  9   6   5  (<-泡沫排序後)(由大至小版本)

#補充: 那為什麼要加內圈for j的原因是因為如果不加,那他最內圈k排出來不管是由小至大還由大至小
#      都只有循環排1次,而且還是排出半成品出來,所以如果要每個高裡面的值各自1個1個由小至大或由
#      大至小那一定要放內圈for j,看我此data目前的高[i],長度值(len)是多少,就丟進去for j,內圈j
#      就跟著循環幾次,之後內圈j帶動最內圈k排出最完美的由小到大或由大至小,這樣一個2維陣列的高裡
#      面的值就變成氣泡排序了,所以在繼續做2維陣列下一個高裡面的值